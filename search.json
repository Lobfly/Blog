[{"title":"Hello World","url":"/Blog/2021/12/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"初次使用Tailwindcss的体验与总结","url":"/Blog/2021/12/08/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8Tailwindcss%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E6%80%BB%E7%BB%93/","content":"刚从vue转react的时候，让我最不习惯的就是css写法的转变。在vue中，css是写在style标签里的，这点与原生写法一致，所以写起来并没有什么不适。并且还可以使用scoped属性隔离作用域，写法十分优雅。而在react中书写css有很多种，虽然刚接触时有点眼花缭乱，但这也是react吸引我的地方，比约定俗成的vue要高得多的自由度让我觉得react很有魅力。\n刚开始的时候我用的方法就是组件内定义类名，引入外部css这种传统方式。但随着组件数量的增多，外部css文件的内容会变得越来越庞大。而且由于这种方式没有作用域隔离，每次写class类名的都会担心这个名字会不会重复，这无疑增加了心智负担。于是我开始了解其它css方案，如styled-components、Css Modules…\n然后就想到了Tailwindcss，这个框架在我刚开始学三件套的时候就有所了解，但原生写法推崇的是样式与结构分离，这种与行内样式差不多的方法在当时的我看起来很不好用。之后学习vue的时候也因为模板语法的写法很方便，并没有再去接触。但是现在上手体验一下过后，Tailwind真香！\n原子化的写法正如Tailwind官网介绍的一样，Tailwind CSS 是一个功能类优先的 CSS 框架。\n在之前的css书写过程中，会因为一些功能而去专门给某个元素写一个类，并给其取一个语义化的类名，比如\n.card_flex_container &#123;  display:flex;  justify-content:center;&#125;\n\n但随着内容越来越多，其它地方也会用到这个居中效果，就会重复书写很多遍这两行代码。这样整个css文件就会有很多重复的地方，显得很杂乱无章。\n也许这个时候有人就会把这些重复的代码抽离出来形成一个单独的居中类。但是在这个抽离的过程中会涉及到代码的查找、删除、添加，以及如何抽离、如何命名类、什么时候该抽离等等问题，这对于一个项目经验不是很多的初学者来说都会有所负担，不能专心于编写逻辑或样式。\n而Tailwind这种提供了功能类的原子化方案在我用起来的时候就会觉得很舒服，因为Tailwind已经按照一套规范把功能抽离成了一个个的类，大多数情况下并不需要自己再手动去抽离一个功能，定义一个类名。而且在组件时代这种类似于行内样式的写法可以很好的融入进组件中，在分离react组件的时候并不会关心css文件的引用、作用域发不发生改变，我想这也是为什么会出现css in js这种写法的原因吧。\nJIT","tags":["总结","Tailwindcss"]},{"title":"前端大文件切片传输","url":"/Blog/2021/10/18/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E7%89%87%E4%BC%A0%E8%BE%93/","content":"前端大文件切片传输File对象\n通常情况下， File 对象是来自用户在一个 input元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。\n\nBlob对象的子类文件FIle对象是Blob对象的子类，继承了Blob对象的属性与方法\n获取File对象通过input.files来获取input元素的FileList对象，而input.value是文件的路径\n属性\nFile.lastModified 返回当前 File 对象所引用文件最后修改时间\nFile.lastModifiedDate 返回当前 File 对象所引用文件最后修改时间的 Date 对象\nFile.name 返回当前 File 对象所引用文件的名字\nFile.size 返回文件的大小\nFile.webkitRelativePath 返回文件的路径\nFile.type 返回文件的类型\n\n方法\nFile 接口没有定义任何方法，但是它从 Blob 接口继承slice方法\n\nBlob.slice - Web API 接口参考 | MDN\n切片大文件传输的问题在一个请求中上传大量数据会导致整个过程时间消耗较久，传输失败后要重头传输，而且用户无法知道传输的进度，体验较差\n所以在对大文件进行传输操作时，可以将大文件进行切片，可以实现如下几个要求\n\n可以断点续传\n可以显示上传的进度，用户体验更好\n\nslice方法对文件切片//chunks数组储存切片文件let chunks = []//slice方法接收两个参数，开始切片和结束切片的比特数,插值即为每个切片的大小，这里为1kblet startByte = 0let endByte = 1024while(startByte&lt;file.size)&#123;    let filePiece = file.slice(startByte,endByte)    chunks.push(filePiece)    startByte = endByte    endByte = startByte + piece&#125;\n\n对chunks进行传输后续添加","tags":["传输"]},{"title":"折腾keep主题","url":"/Blog/2021/12/02/%E6%8A%98%E8%85%BEkeep%E4%B8%BB%E9%A2%98/","content":"折腾keep主题\nbg.svg显示问题，明明是放在images目录下却一直请求不到。为此搞了个PicX图床，打算之后用koa做一个自己的图床服务器出来。\n点击Toc目录会把header栏给隐藏掉，然后无法从页面上跳转回主页，我感觉这样很反人类。一开始以为这是个bug，研究源码后发现这是个特性。。。可能作者认为toc和header一起显示会有点不协调  // source/js/toc.jscomplete: function () &#123;\tsetTimeout(() =&gt; &#123;\t\tKEEP.utils.pageTop_dom.classList.add(&#x27;hide&#x27;);\t&#125;, 100)&#125;\n  于是只能自己动手，实现了打开左侧toc栏隐藏header，关闭则显示header栏  // source/js/left-side-toggle.jsif(isOpen) &#123;  KEEP.utils.pageTop_dom.classList.add(&#x27;hide&#x27;);&#125; else &#123;  KEEP.utils.pageTop_dom.classList.remove(&#x27;hide&#x27;);&#125;\n\n点击header栏的 “Lobfly’s Blog”title后会跳转到lobfly.github.io这个网址，而我的博客是部署在lobfly.github.io/Blog/ 上的，又得去研究ejs代码  发现header.ejs中两个href的属性是”/“，改成”Blog“就能实现正确跳转了  &lt;% if (theme.base_info.hasOwnProperty(&#x27;logo_img&#x27;) &amp;&amp; theme.base_info.logo_img) &#123; %&gt;    &lt;a class=&quot;logo-image&quot; href=&quot;/&quot;&gt;        &lt;%- image_tag(theme.base_info.logo_img) %&gt;    &lt;/a&gt;&lt;% &#125; %&gt;&lt;a class=&quot;logo-title&quot; href=&quot;/&quot;&gt;    &lt;%= theme.base_info.title || config.title || &#x27;Keep Theme&#x27; %&gt;&lt;/a&gt;\n\n","tags":["源码"]},{"title":"搭建图床服务的总结","url":"/Blog/2021/12/05/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%80%BB%E7%BB%93/","content":"搭建图床服务的总结因为做博客需要图片外链的原因，开始关注图床服务。一开始发现了PicX是基于github仓库来储存图片的，使用起来感觉很简单方便，图片放在自己的仓库上也比较放心。但是自己也想折腾一个简单的图床服务出来，一是自己花了钱买了台小服务器一直空着，二是没用nodejs搭过一个完整的项目，最近也在学习react，刚好可以通过这个项目在这两方面练练手。\n后端因为是个小项目，所以使用了koa作为框架。还有一个原因是koa灵活度很高，适合我这种爱折腾的人，做个人项目的话很喜欢这种轻量级的框架。\n文件路径涉及到上传、删除、查询这些文件操作，就必须解决路径的问题\n路径获取\nprocess.cwd() ：进程执行的工作目录 (可以理解为根目录)\n__dirname ： 当前模块的目录路径\n\n\n具体点来说就是process.cwd()是执行node index.js的那个目录，而__dirname是所在js文件的那个目录。即入口文件index.js中，process.cwd()和__dirname指向的都是同一个目录\n\n\n__filename ： 返回当前模块的文件路径 （比__dirname多了个文件名）\n\nC:\\Users\\28492\\Desktop\\Image-Hosting\\backend           //__dirnameC:\\Users\\28492\\Desktop\\Image-Hosting\\backend\\index.js  //__filename\n\n路径解析\n“.”被解析成当前目录    解析时相当于一个空操作，空字符串就会被解析成”.”\n“..”被解析为上一层目录    解析时会将上一级路径去掉\n\npath.normalize()：获取规范化的路径\n该方法会规范化给定的 path，并解析 ‘..’ 和 ‘.’ 片段\n当发现多个连续的路径分隔符时（如 POSIX 上的 / 与 Windows 上的 \\ 或 /），它们会被单个的路径分隔符（POSIX 上是 /，Windows 上是 \\）替换\n\nWindows系统下，’/‘和’&#39;均可以表示路径，但是在网络链接里只能用’/ ‘表示路径\n\npath.join([…paths])：拼接路径\n该方法会先把路径拼接在一起，然后进行规范化（即path.normalize），返回正确的路径\n相当于\npath.normalize(paths.join(&#x27;/&#x27;))\n\npath.resolve([…paths])：智能解析绝对路径\n该方法会把一个路径或路径片段的序列从左往右解析为一个绝对路径\n解析规则：\n\n以“/”开头的路径会将前面的路径丢弃掉，因为表示一个绝对路径（而join只是简单的拼接）\n…后续总结\n\n文件操作上传文件这里用了fs模块的流传输，分别创建可读流和写入流通过pipe方法传输数据\npipe的用法：readStream.pipe(writeStream)\n可以形象的记忆为水流从一个装满水的桶子流到一个空的桶子，可读流理解为装满水的桶，写入流理解为空桶\n获取文件获取路径列表的逻辑很简单，就是把参数和路径字符串拼接到一起然后返回\n获取图片则需要设置一下响应头的Content-Type为image/jpeg，然后返回的数据才能正确显示为图片格式而不是单纯的数据文件\n删除文件删除文件使用了fs模块的unlink方法\n\nfs.unlink() 不适用于目录，无论是空目录还是其他目录。 要删除目录，请使用 fs.rmdir()\n\n关于文件操作踩的坑fs模块中的文件读写等操作都是异步进行的，需要在外面包一层Promise\n一开始受koa内部的async await影响，以为直接在文件读写操作后加一个await，然后再在下面设置response就可以了，然而读写操作返回的并不是一个Promise对象\n对于文件操作，nodejs提供了另外一套返回 promise 的异步文件操作方法\n使用时需要从&#39;fs/promises&#39; 里面导入，如\nimport &#123; readFile &#125; from &#x27;fs/promises&#x27;;import &#123; readFile &#125; from &#x27;fs&#x27;; //区分\n\nfs 文件系统 | Node.js API 文档\nPromise操作里还踩的一个坑是resolve不会终止执行函数\nawait new Promise((resolve)=&gt;&#123;        fs.unlink(imgPath,(err)=&gt;&#123;            if(err) &#123;                ctx.body = &#x27;删除失败，不存在该文件&#x27;                resolve()            &#125; else &#123;                //不加else的话resolve之后还是会执行下面的语句                ctx.body = &#x27;删除成功&#x27;                resolve()            &#125;        &#125;)    &#125;)\n\n\n调用resolve或reject并不会终结 Promise 的参数函数的执行 ，最好在它们前面加上return语句\n\n中间件的使用以后考虑写一个中间件使用总结\nkoa-body待补充\nkoa2-cors待补充\n","tags":["总结"]}]