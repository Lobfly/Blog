[{"title":"前端大文件切片传输","url":"/Blog/2021/10/18/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E7%89%87%E4%BC%A0%E8%BE%93/","content":"前端大文件切片传输File对象\n通常情况下， File 对象是来自用户在一个 input元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。\n\nBlob对象的子类文件FIle对象是Blob对象的子类，继承了Blob对象的属性与方法\n获取File对象通过inout.files来获取input元素的FileList对象，而input.value是文件的路径\n属性\nFile.lastModified 返回当前 File 对象所引用文件最后修改时间\nFile.lastModifiedDate 返回当前 File 对象所引用文件最后修改时间的 Date 对象\nFile.name 返回当前 File 对象所引用文件的名字\nFile.size 返回文件的大小\nFile.webkitRelativePath 返回文件的路径\nFile.type 返回文件的类型\n\n方法\nFile 接口没有定义任何方法，但是它从 Blob 接口继承slice方法\n\nBlob.slice - Web API 接口参考 | MDN\n切片大文件传输的问题在一个请求中上传大量数据会导致整个过程时间消耗较久，传输失败后要重头传输，而且用户无法知道传输的进度，体验较差\n所以在对大文件进行传输操作时，可以将大文件进行切片，可以实现如下几个要求\n\n可以断点续传\n可以显示上传的进度，用户体验更好\n\nslice方法对文件切片//chunks数组储存切片文件let chunks = []//slice方法接收两个参数，开始切片和结束切片的比特数,插值即为每个切片的大小，这里为1kblet startByte = 0let endByte = 1024while(startByte&lt;file.size)&#123;    let filePiece = file.slice(startByte,endByte)    chunks.push(filePiece)    startByte = endByte    endByte = startByte + piece&#125;\n\n对chunks进行传输后续添加","tags":["传输"]},{"title":"Hello World","url":"/Blog/2021/12/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"折腾keep主题","url":"/Blog/2021/12/02/%E6%8A%98%E8%85%BEkeep%E4%B8%BB%E9%A2%98/","content":"折腾keep主题\nbg.svg显示问题，明明是放在images目录下却一直请求不到。为此搞了个PicX图床，打算之后用koa做一个自己的图床服务器出来。\n点击Toc目录会把header栏给隐藏掉，然后无法从页面上跳转回主页，我感觉这样很反人类。一开始以为这是个bug，研究源码后发现这是个特性。。。可能作者认为toc和header一起显示会有点不协调  // source/js/toc.jscomplete: function () &#123;\tsetTimeout(() =&gt; &#123;\t\tKEEP.utils.pageTop_dom.classList.add(&#x27;hide&#x27;);\t&#125;, 100)&#125;\n  于是只能自己动手，实现了打开左侧toc栏隐藏header，关闭则显示header栏  // source/js/left-side-toggle.jsif(isOpen) &#123;  KEEP.utils.pageTop_dom.classList.add(&#x27;hide&#x27;);&#125; else &#123;  KEEP.utils.pageTop_dom.classList.remove(&#x27;hide&#x27;);&#125;\n\n点击header栏的 “Lobfly’s Blog”title后会跳转到lobfly.github.io这个网址，而我的博客是部署在lobfly.github.io/Blog/ 上的，又得去研究ejs代码  发现header.ejs中两个href的属性是”/“，改成”Blog“就能实现正确跳转了  &lt;% if (theme.base_info.hasOwnProperty(&#x27;logo_img&#x27;) &amp;&amp; theme.base_info.logo_img) &#123; %&gt;    &lt;a class=&quot;logo-image&quot; href=&quot;/&quot;&gt;        &lt;%- image_tag(theme.base_info.logo_img) %&gt;    &lt;/a&gt;&lt;% &#125; %&gt;&lt;a class=&quot;logo-title&quot; href=&quot;/&quot;&gt;    &lt;%= theme.base_info.title || config.title || &#x27;Keep Theme&#x27; %&gt;&lt;/a&gt;\n\n","tags":["源码"]},{"title":"搭建图床服务的总结","url":"/Blog/2021/12/03/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%80%BB%E7%BB%93/","content":"搭建图床服务的总结因为做博客需要图片外链的原因，开始关注图床服务。一开始发现了PicX是基于github仓库来储存图片的，使用起来感觉很简单方便，图片放在自己的仓库上也比较放心。但是自己也想折腾一个简单的图床服务出来，一是自己花了钱买了台小服务器一直空着，二是没用nodejs搭过一个完整的项目，最近也在学习react，刚好可以通过这个项目在这两方面练练手。\n后端因为是个小项目，所以使用了koa作为框架。还有一个原因是koa灵活度很高，适合我这种爱折腾的人，做个人项目的话很喜欢这种轻量级的框架。\n文件路径涉及到上传、删除、查询这些文件操作，就必须解决路径的问题\n路径获取\nprocess.cwd() ：进程执行的工作目录 (可以理解为根目录)\n__dirname ： 当前模块的目录路径\n\n\n具体点来说就是process.cwd()是执行node index.js的那个目录，而__dirname是所在js文件的那个目录。即入口文件index.js中，process.cwd()和__dirname指向的都是同一个目录\n\n\n__filename ： 返回当前模块的文件路径 （比__dirname多了个文件名）\n\nC:\\Users\\28492\\Desktop\\Image-Hosting\\backend           //__dirnameC:\\Users\\28492\\Desktop\\Image-Hosting\\backend\\index.js  //__filename\n\n路径解析\n“.”被解析成当前目录    解析时相当于一个空操作，空字符串就会被解析成”.”\n“..”被解析为上一层目录    解析时会将上一级路径去掉\n\npath.normalize()：获取规范化的路径\n该方法会规范化给定的 path，并解析 ‘..’ 和 ‘.’ 片段\n当发现多个连续的路径分隔符时（如 POSIX 上的 / 与 Windows 上的 \\ 或 /），它们会被单个的路径分隔符（POSIX 上是 /，Windows 上是 \\）替换\n\nWindows系统下，’/‘和’&#39;均可以表示路径，但是在网络链接里只能用’/‘表示路径\n\npath.join([…paths])：拼接路径\n该方法会先把路径拼接在一起，然后进行规范化（即path.normalize），返回正确的路径\n相当于\npath.normalize(paths.join(&#x27;/&#x27;))\n\npath.resolve([…paths])：智能解析绝对路径\n该方法会把一个路径或路径片段的序列从左往右解析为一个绝对路径\n解析规则：\n\n以“/”开头的路径会将前面的路径丢弃掉，因为表示一个绝对路径（而join只是简单的拼接）\n…后续总结\n\n文件操作上传文件获取文件删除文件","tags":["总结"]}]